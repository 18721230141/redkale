<?xml version="1.0" encoding="UTF-8"?>
<!-- 
    文件说明:
        ${APP_HOME} 指当前程序的总目录APP_HOME
        required： 被声明required的属性值不能为空
        
                                            group
                                         /  /  \  \  
                                      /    /    \   \   
                                   /     /       \    \                      
                               node1   node2   node3  node4
                             /       \                             
                          /             \
                       /                   \
                    /                         \
             serviceid1                       serviceid2
            /       \                        /       \
  serviceid1_name1  serviceid1_name2   serviceid2_name1  serviceid2_name2    
-->
<!--     
    address:  本地的IP地址， 默认值为默认网卡的ip，当不使用默认值需要指定值，如127.0.0.1
    port: required  程序的管理Server的端口，用于关闭或者与监管系统进行数据交互
    host:  程序的管理Server的地址; 默认为127.0.0.1。
    lib:  加上额外的lib路径,多个路径用分号;隔开； 默认为空。  例如: ${APP_HOME}/lib/a.jar;${APP_HOME}/lib2/b.jar;
-->
<application port="6560" lib="">   
    
    <!-- 所有服务所需的资源 -->      
    <resources>
        
        <!--  设置系统的 DataCacheListener 的Service实现，值[none]表示不需要启动DataCacheListener同步， 默认为系统自带实现类 -->
        <datacachelistener service="none"/>
        
        <!--  设置系统的 WebSocketNode 的Service实现， 值[none]表示不需要启动WebSocketNode同步，默认为系统自带实现类 -->
        <websocketnode service="xxxx"/>
        
         <!--
            一个组包含多个NODE， 同一Service服务可以由多个进程提供，这些进程称为一个GROUP，且同一GROUP内的进程必须在同一机房或局域网内
            name: 服务组ID，长度不能超过11个字节. 默认为空字符串。
            protocol：值只能是UDP TCP， 默认UDP
        -->
        <group name="" protocol="UDP">
            <!--
                需要将本地node的addr与port列在此处。
                addr: required IP地址
                port: required 端口
                clients: 连接池数， 默认: CPU核数*4
                buffers: ByteBuffer对象池的大小， 默认: CPU核数*8
            -->
            <node addr="127.0.0.1" port="7070"/>
        </group>
        <!--
            远程client地址组资源.  注意:  remote的name值不能为LOCAL（不区分大小写）
            protocol： 值只能是UDP TCP， 默认UDP
            clients:  连接池数， 默认: CPU核数*8
            buffers: ByteBuffer对象池的大小， 默认: CPU核数*16
            group:  组名， 默认是空字符串， 通常不同机房使用不同的group值
        -->
        <remote name="myremote" protocol="UDP" group="">
            <!--
                weight: 权重百分比。 不指定则平均。 weight之和必须<=100
                [注: weight尚未实现]
            -->
            <address addr="127.0.0.1" port="7070" weight="30"/>
            <address addr="127.0.0.1" port="7071" weight="30"/>
            <address addr="127.0.0.1" port="7072" weight="40"/>
        </remote>
        <!-- 
            全局的参数配置, 可以通过@Resource(name="property.xxxxxx") 进行注入, 被注解的字段类型只能是String、primitive class
            如果name是system.property.开头的值将会在进程启动时进行System.setProperty("yyyy", "YYYYYY")操作。
            load:  加载文件，多个用;隔开。
            默认置入的system.property.的有：
               System.setProperty("convert.bson.pool.size", "128");
               System.setProperty("convert.json.pool.size", "128");
               System.setProperty("convert.bson.writer.buffer.defsize", "4096");
               System.setProperty("convert.json.writer.buffer.defsize", "4096");
        -->
        <properties load="config.properties">
            <property name="system.property.yyyy" value="YYYYYY"/>
            <property name="xxxxxx" value="XXXXXXXX"/>
            <property name="xxxxxx" value="XXXXXXXX"/>
            <property name="xxxxxx" value="XXXXXXXX"/>
        </properties>
    </resources> 
    <!--
        protocol: required  server所启动的协议，有HTTP、SNCP， 目前只支持HTTP、SNCP。SNCP也分TCP、UDP实现，默认使用UDP实现，TCP实现则使用SNCP.TCP值; 
        host:  服务所占address ， 默认: 0.0.0.0
        port:  required 服务所占端口 
        group: 所属组的节点,多个节点值用;隔开，如果配置文件中存在多个SNCP协议的Server节点，需要显式指定group属性
        root:  如果是web类型服务，则包含页面  默认:{APP_HOME}/root
        lib: server额外的class目录， 默认为空        
        charset: 文本编码， 默认: UTF-8
        backlog:  默认10K
        threads： 线程总数， 默认: CPU核数*16
        maxbody: request.body最大值， 默认: 64K
        capacity: ByteBuffer的初始化大小， 默认: 8K;  如果是HTTP协议则默认: 16K + 8B (HTTP 2.0)
        bufferPoolSize： ByteBuffer池的大小，默认: CPU核数*512
        responsePoolSize： Response池的大小，默认: CPU核数*256
        readTimeoutSecond: 读操作超时秒数， 默认0， 表示永久不超时
        writeTimeoutSecond:  写操作超时秒数， 默认0， 表示永久不超时
        
        forwardproxy: 正向代理(支持CONNECT); 默认: false， 只有当protocol=HTTP才生效
    -->
    <server protocol="HTTP" host="127.0.0.1" port="6060" root="root" lib=""> 
        
        <!-- 
           加载所有的Service服务;
           在同一个进程中所有LOCAL模式的Service， 同一个name的将共用同一个实例
           autoload="true"  默认值. 自动加载以下目录（如果存在的话）下所有的Service类:
                                 server.lib;    server.lib/*;    server.classes;    
           autoload="false" 需要显著的指定Service类
           includes： 当autoload="true"， 拉取类名与includes中的正则表达式匹配的类, 多个正则表达式用分号;隔开
           excludes： 当autoload="true"， 排除类名与includes中的正则表达式匹配的类, 多个正则表达式用分号;隔开
        -->
        <services autoload="true" includes="" excludes="">
            <!--
               大部分的情况下， 存在多个节点环境中很多service节点配置都一致，为此提供group节点来方便配置。
               remotenames: 远程模式Service的name名称集合， 多个用分号;隔开， 名称必须是在resources节点中定义的remote节点。
               以下group节点例子等价于:
                <service value="com.xxx.XXX0Service" name="" remote="LOCAL"/>
                <service value="com.xxx.XXX0Service" name="RT001" remote="RT001"/>
                <service value="com.xxx.XXX0Service" name="RT002" remote="RT002"/>
                <service value="com.xxx.XXX0Service" name="RT003" remote="RT003"/>
            -->
            <group remotenames="RT001;RT002;RT003">
                <service value="com.xxx.XXX0Service"/>
            </group>
            
            <!-- 显著加载指定的Service的接口类 -->
            <service value="com.xxx.XXX1Service"/>
            <!-- 
               设定remote=LOCAL时 则表示该service为本地模式， 同时忽略<services>节点的remote值。
               name表示被@Resource注入时指定的name
               设定remote为非空非LOCAL且值在<resources>中有定义时 则表示该service为远程模式， 同时忽略<services>节点的remote值。
            -->
            <service value="com.xxx.XXX2Service" name="" remote="LOCAL"/>
            <!--   给Service增加配置属性 -->
            <service value="com.xxx.XXX1Service">
                <property name="xxxxxx" value="XXXXXXXX"/>
                <property name="xxxxxx" value="XXXXXXXX"/>
            </service>
        </services>
        
        <!--
           当Server为HTTP协议时, request节点才有效。
           remoteaddr 节点: 替换请求方节点的IP地址， 通常请求方是由nginx等web静态服务器转发过的则需要配置该节点。
           且value值只能是以request.headers.开头，表示从request.headers中获取对应的header值。
           例如下面例子获取request.getRemoteAddr()值，如果header存在X-RemoteAddress值则返回X-RemoteAddress值，不存在返回request.getRemoteAddress()。
        -->
        <request>
            <remoteaddr value="request.headers.X-RemoteAddress"/>
        </request>
        
        <!--
           当Server为HTTP协议时, response节点才有效。
           defcookie 节点: 当response里输出的cookie没有指定domain 和path时，使用该节点的默认值。
           如果addheader、setheader 的value值以request.headers.开头则表示从request.headers中获取对应的header值
           例如下面例子是在Response输出header时添加两个header（一个addHeader， 一个setHeader）。
        -->
        <response>
            <defcookie domain="" path=""/>
            <addheader name="Access-Control-Allow-Origin" value="request.headers.Origin" /> 
            <setheader name="Access-Control-Allow-Credentials" value="true"/> 
        </response>
            
        <!-- 
           加载所有的Servlet服务;
           prefix:  servlet的ContextPath前缀 默认为空
           autoload="true"  默认值. 自动加载以下目录（如果存在的话）下所有的Servlet类:
                                 ${APP_HOME}/lib;    ${APP_HOME}/root/lib/*;    ${APP_HOME}/root/classes;   
           autoload="false" 需要显著的指定Service类
           includes： 当autoload="true"， 拉取类名与includes中的正则表达式匹配的类, 多个正则表达式用分号;隔开
           excludes： 当autoload="true"， 排除类名与excludes中的正则表达式匹配的类, 多个正则表达式用分号;隔开
        -->
        <servlets prefix="/pipes" autoload="true" includes="" excludes="">
            <!-- 
               当Server为HTTP协议时，ResourceServlet才有效. 默认存在一个有默认属性的resource-servlet节点
               webroot: web资源的根目录, 多个目录用;分隔，请求页面url时，如果第一个目录不存在则会查询下一个目录是否存在该文件至到所有目录集合， 默认取server节点中的root值
            -->
            <resource-servlet webroot="root">
                <!--
                    资源缓存的配置, 默认存在一个含默认属性的caches节点
                    limit:  资源缓存最大容量， 默认: 128M, 为0表示不缓存
                    lengthmax: 可缓存的文件大小上限， 默认: 1M（超过1M的文件不会被缓存）
                -->
                <caches  limit="128M" lengthmax="1M" />
                <!--
                   支持类似nginx中的rewrite， 目前只支持静态资源对静态资源的跳转。
                   type: 匹配的类型, 目前只支持location(匹配requestURI), 默认: location
                   match: 匹配的正则表达式
                   forward: 需跳转后的资源链接
                   例如下面例子是将/xxx-yyy.html的页面全部跳转到/xxx.html
                -->
                <rewrite type="location" match="^/([^-]+)-[^-\.]+\.html(.*)" forward="/$1.html"/>
            </resource-servlet>
            <!-- 显著加载指定的Servlet -->
            <servlet value="com.xxx.XXX1Servlet" />
            <servlet value="com.xxx.XXX2Servlet" />
            <servlet value="com.xxx.XXX3Servlet" >
                <property name="xxxxxx" value="XXXXXXXX"/>
                <property name="xxxxxx" value="XXXXXXXX"/>
            </servlet>
        </servlets>
    </server>
    
    <server protocol="SNCP" host="127.0.0.1" port="7070" root="root" lib=""> 
        <!--
            参数完全同上
        -->
        <services autoload="true" includes="" excludes="" />
    </server>
</application>
