/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.wentch.redkale.source;

import com.sun.istack.internal.logging.Logger;
import com.wentch.redkale.util.*;
import java.io.Serializable;
import java.lang.reflect.*;
import java.sql.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Function;
import java.util.logging.*;
import javax.persistence.*;

/**
 *
 * @author zhangjx
 * @param <T>
 */
@SuppressWarnings("unchecked")
public final class EntityInfo<T> {

    private static final ConcurrentHashMap<Class, EntityInfo> entityInfos = new ConcurrentHashMap<>();

    private static final Logger logger = Logger.getLogger(EntityInfo.class);

    static final Set<Class> cacheClasses = new HashSet<>();

    //Entity类的类名
    private final Class<T> type;

    //类对应的数据表名
    private final String table;

    private final Creator<T> creator;

    //主键
    private final Attribute<T, Serializable> primary;

    private final EntityCache<T> cache;

    //key是field的name， value是Column的别名，即数据库表的字段名
    //只有field.name 与 Column.name不同才存放在aliasmap里.
    private final Map<String, String> aliasmap;

    //key是field的name， 不是sql字段。
    //存放所有与数据库对应的字段， 包括主键
    private final Map<String, Attribute<T, Serializable>> attributes = new HashMap<>();

    private final Map<String, Attribute<T, Serializable>> updateAttributeMap = new HashMap<>();

    final String querySQL;

    private final Attribute<T, Serializable>[] queryAttributes; //数据库中所有字段

    final String insertSQL;

    final Attribute<T, Serializable>[] insertAttributes; //数据库中所有可新增字段

    final String updateSQL;

    final Attribute<T, Serializable>[] updateAttributes; //数据库中所有可更新字段

    final String deleteSQL;

    private final int logLevel;

    //---------------------计算主键值----------------------------
    private final int nodeid;

    final Class[] distributeTables;

    final boolean autoGenerated;

    final boolean distributed;

    boolean initedPrimaryValue = false;

    final AtomicLong primaryValue = new AtomicLong(0);

    final int allocationSize;
    //------------------------------------------------------------

    public static <T> EntityInfo<T> load(Class<T> clazz, final int nodeid,
        Function<Class, List> fullloader) {
        EntityInfo rs = entityInfos.get(clazz);
        if (rs != null) return rs;
        synchronized (entityInfos) {
            rs = entityInfos.get(clazz);
            if (rs == null) {
                rs = new EntityInfo(clazz, nodeid, fullloader);
                entityInfos.put(clazz, rs);
            }
            return rs;
        }
    }

    private EntityInfo(Class<T> type, int nodeid, Function<Class<T>, List<T>> fullloader) {
        this.type = type;
        //---------------------------------------------
        this.nodeid = nodeid;
        DistributeGenerator.DistributeTables dt = type.getAnnotation(DistributeGenerator.DistributeTables.class);
        this.distributeTables = dt == null ? null : dt.value();

        LogLevel ll = type.getAnnotation(LogLevel.class);
        this.logLevel = ll == null ? Integer.MIN_VALUE : Level.parse(ll.value()).intValue();
        //---------------------------------------------
        Table t = type.getAnnotation(Table.class);
        this.table = (t == null) ? type.getSimpleName().toLowerCase() : (t.catalog().isEmpty()) ? t.name() : (t.catalog() + '.' + t.name());
        this.creator = Creator.create(type);
        Attribute idAttr0 = null;
        Map<String, String> aliasmap0 = null;
        Class cltmp = type;
        Set<String> fields = new HashSet<>();
        List<Attribute<T, Serializable>> queryattrs = new ArrayList<>();
        List<String> insertcols = new ArrayList<>();
        List<Attribute<T, Serializable>> insertattrs = new ArrayList<>();
        List<String> updatecols = new ArrayList<>();
        List<Attribute<T, Serializable>> updateattrs = new ArrayList<>();
        boolean auto = false;
        boolean sqldistribute = false;
        int allocationSize0 = 0;

        do {
            for (Field field : cltmp.getDeclaredFields()) {
                if (Modifier.isStatic(field.getModifiers())) continue;
                if (Modifier.isFinal(field.getModifiers())) continue;
                if (field.getAnnotation(Transient.class) != null) continue;
                if (fields.contains(field.getName())) continue;
                final String fieldname = field.getName();
                final Column col = field.getAnnotation(Column.class);
                final String sqlfield = col == null || col.name().isEmpty() ? fieldname : col.name();
                if (!fieldname.equals(sqlfield)) {
                    if (aliasmap0 == null) aliasmap0 = new HashMap<>();
                    aliasmap0.put(fieldname, sqlfield);
                }
                Attribute attr;
                try {
                    attr = Attribute.create(cltmp, field);
                } catch (RuntimeException e) {
                    continue;
                }
                if (field.getAnnotation(javax.persistence.Id.class) != null && idAttr0 == null) {
                    idAttr0 = attr;
                    GeneratedValue gv = field.getAnnotation(GeneratedValue.class);
                    auto = gv != null;
                    if (gv != null && gv.strategy() != GenerationType.IDENTITY) {
                        throw new RuntimeException(cltmp.getName() + "'s @ID primary not a GenerationType.IDENTITY");
                    }
                    DistributeGenerator dg = field.getAnnotation(DistributeGenerator.class);
                    if (dg != null) {
                        if (!field.getType().isPrimitive()) throw new RuntimeException(cltmp.getName() + "'s @DistributeGenerator primary must be primitive class type field");
                        sqldistribute = true;
                        auto = false;
                        allocationSize0 = dg.allocationSize();
                        primaryValue.set(dg.initialValue());
                    }
                    if (!auto) {
                        insertcols.add(sqlfield);
                        insertattrs.add(attr);
                    }
                } else {
                    if (col == null || col.insertable()) {
                        insertcols.add(sqlfield);
                        insertattrs.add(attr);
                    }
                    if (col == null || col.updatable()) {
                        updatecols.add(sqlfield);
                        updateattrs.add(attr);
                        updateAttributeMap.put(fieldname, attr);
                    }
                }
                queryattrs.add(attr);
                fields.add(fieldname);
                attributes.put(fieldname, attr);
            }
        } while ((cltmp = cltmp.getSuperclass()) != Object.class);
        this.primary = idAttr0;
        this.aliasmap = aliasmap0;
        {
            this.queryAttributes = queryattrs.toArray(new Attribute[queryattrs.size()]);
            this.insertAttributes = insertattrs.toArray(new Attribute[insertattrs.size()]);
            this.updateAttributes = updateattrs.toArray(new Attribute[updateattrs.size()]);
            StringBuilder insertsb = new StringBuilder();
            StringBuilder insertsb2 = new StringBuilder();
            for (String col : insertcols) {
                if (insertsb.length() > 0) insertsb.append(',');
                insertsb.append(col);
                if (insertsb2.length() > 0) insertsb2.append(',');
                insertsb2.append('?');
            }
            this.insertSQL = "INSERT INTO " + table + "(" + insertsb + ") VALUES(" + insertsb2 + ")";
            StringBuilder updatesb = new StringBuilder();
            for (String col : updatecols) {
                if (updatesb.length() > 0) updatesb.append(',');
                updatesb.append(col).append(" = ?");
            }
            this.updateSQL = "UPDATE " + table + " SET " + updatesb + " WHERE " + getPrimarySQLColumn() + " = ?";
            this.deleteSQL = "DELETE FROM " + table + " WHERE " + getPrimarySQLColumn() + " = ?";
            this.querySQL = "SELECT * FROM " + table + " WHERE " + getPrimarySQLColumn() + " = ?";
        }
        this.autoGenerated = auto;
        this.distributed = sqldistribute;
        this.allocationSize = allocationSize0;
        //----------------cache--------------
        Cacheable c = type.getAnnotation(Cacheable.class);
        boolean cf = (c == null) ? (cacheClasses != null && cacheClasses.contains(type)) : false;
        if ((c != null && c.value()) || cf) {
            this.cache = new EntityCache<>(type, creator, primary, attributes, fullloader);
        } else {
            this.cache = null;
        }
    }

    public void createPrimaryValue(T src) {
        long v = allocationSize > 1 ? (primaryValue.incrementAndGet() * allocationSize + nodeid) : primaryValue.incrementAndGet();
        if (primary.type() == int.class || primary.type() == Integer.class) {
            getPrimary().set(src, (Integer) ((Long) v).intValue());
        } else {
            getPrimary().set(src, v);
        }
    }

    EntityCache<T> getCache() {
        return cache;
    }

    public Creator<T> getCreator() {
        return creator;
    }

    public Class<T> getType() {
        return type;
    }

    public String getTable() {
        return table;
    }

    public Attribute<T, Serializable> getPrimary() {
        return this.primary;
    }

    public Attribute<T, Serializable> getAttribute(String fieldname) {
        return this.attributes.get(fieldname);
    }

    public Attribute<T, Serializable> getUpdateAttribute(String fieldname) {
        return this.updateAttributeMap.get(fieldname);
    }

    public boolean isNoAlias() {
        return this.aliasmap == null;
    }

    //根据field字段名获取数据库对应的字段名
    public String getSQLColumn(String fieldname) {
        return this.aliasmap == null ? fieldname : aliasmap.getOrDefault(fieldname, fieldname);
    }

    //数据库字段名
    public String getPrimarySQLColumn() {
        return getSQLColumn(this.primary.field());
    }

    public Map<String, Attribute<T, Serializable>> getAttributes() {
        return attributes;
    }

    public boolean isLoggable(Level l) {
        return l.intValue() >= this.logLevel;
    }

    public T getValue(SelectColumn sels, ResultSet set) throws SQLException {
        T obj = creator.create();
        for (Attribute<T, Serializable> attr : queryAttributes) {
            if (sels == null || sels.validate(attr.field())) {
                Serializable o = (Serializable) set.getObject(this.getSQLColumn(attr.field()));
                if (o != null) {
                    if (type == long.class) {
                        o = ((Number) o).longValue();
                    } else if (type == int.class) {
                        o = ((Number) o).intValue();
                    } else if (type == short.class) {
                        o = ((Number) o).shortValue();
                    }
                }
                attr.set(obj, o);
            }
        }
        return obj;
    }
}
